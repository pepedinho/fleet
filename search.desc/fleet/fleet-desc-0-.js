searchState.loadedDescShard("fleet", 0, "Returns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBuilds an [<code>AddWatch</code>] request after validating …\nBuilds a [<code>LogsWatches</code>] request from CLI or repository …\nBuilds the appropriate <code>DaemonRequest</code> for the given CLI …\nHandles watch-related CLI commands by delegating to …\nProcesses the <code>DaemonResponse</code> by printing success, error, …\nPrints a formatted table of active watches.\nReads a single line response from the daemon and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLoop through the watches, call <code>watch_once</code> on each one, …\n<code>start_socket_listener</code>\n<code>supervisor_loop</code>\nUpdates the commit stored in the state for a given watch.\n<code>AppState</code>\nadds a view to the watches.json file\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nload watches.json file and Serialize it into WatchRegistry\ndeletes a WatchContext in the watches.json file\n<code>WatchContext</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nwatch_once\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRegisters a new watch, updates the application state, and …\nReturns a list of all current watches as a …\nFetches logs for a given watch by ID or name. If the watch …\nHandles a daemon request and sends the resulting …\nRm a watch by ID if it exists in the application state.\nStops a watch by ID if it exists in the application state.\nRun a watch by ID if it exists in the application state.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\ncall at the end of the pipeline\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nstart job (just insert it with Running status)\nEmpty and retrieve ready jobs from the queue\nManage job failure (log, métrics, notifications)\nInit job queue with job ready to execute based on graph\nRuns a single job with step and dependency management\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nthis function take ctx and msg msg will be split on “:/:…\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")